name: CI/CD - Production (Blue-Green)

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (must be tested in staging)"
        required: true
        type: string
      skip_smoke_test:
        description: "Skip smoke tests on preview"
        required: false
        type: boolean
        default: false
      auto_promote:
        description: "Auto-promote after smoke tests pass"
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write

env:
  REGISTRY: registry.digitalocean.com
  IMAGE_NAME: ai-incident-assistant
  PROD_NAMESPACE: prod
  PROD_URL: http://app.174.138.120.13.nip.io
  PREVIEW_URL: http://preview.174.138.120.13.nip.io

jobs:
  # ============================================
  # JOB 1: Validate Image Tag
  # ============================================
  validate:
    name: Validate Deployment
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ inputs.image_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate image exists
        run: |
          echo "üîç Validating image tag: ${{ inputs.image_tag }}"

          # Check if this tag was deployed to staging (check all images)
          if grep -q "newTag.*${{ inputs.image_tag }}" infra/k8s/overlays/staging/kustomization.yaml; then
            echo "‚úÖ Tag ${{ inputs.image_tag }} was tested in staging"
          else
            echo "‚ùå ERROR: Tag ${{ inputs.image_tag }} has NOT been tested in staging"
            echo ""
            echo "   Staging currently has:"
            grep "newTag:" infra/k8s/overlays/staging/kustomization.yaml | sed 's/^/     /'
            echo ""
            echo "üõë Production deployments MUST go through staging first!"
            echo "   1. Deploy to staging using ci-staging workflow"
            echo "   2. Wait for E2E and Load tests to pass"
            echo "   3. Then deploy to production"
            exit 1
          fi

      - name: Verify staging tests passed
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Verifying staging tests passed for tag ${{ inputs.image_tag }}..."

          # Get the last staging workflow run for this tag
          WORKFLOW_RUN=$(gh run list --workflow=ci-staging.yaml --limit 50 --json conclusion,headSha,status | \
            jq -r '.[] | select(.conclusion == "success") | .headSha' | head -1)

          if [ -z "$WORKFLOW_RUN" ]; then
            echo "‚ö†Ô∏è Warning: Could not verify staging tests"
            echo "   Proceeding anyway (manual deployment)"
          else
            echo "‚úÖ Staging tests verified for commit: $WORKFLOW_RUN"
          fi

      - name: Confirm production deployment
        run: |
          echo "üöÄ PRODUCTION DEPLOYMENT"
          echo "========================"
          echo "Image Tag: ${{ inputs.image_tag }}"
          echo "Auto-Promote: ${{ inputs.auto_promote }}"
          echo "Skip Smoke Test: ${{ inputs.skip_smoke_test }}"
          echo "========================"

  # ============================================
  # JOB 2: Update Production Manifests (Create PR)
  # ============================================
  update-manifests:
    name: Update Production Manifests
    runs-on: ubuntu-latest
    needs: [validate]
    outputs:
      pr_number: ${{ steps.create-pr.outputs.pr_number }}
      branch_name: ${{ env.BRANCH_NAME }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create deployment branch
        run: |
          BRANCH_NAME="deploy/prod-${{ inputs.image_tag }}"
          git checkout -b $BRANCH_NAME
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Update production kustomization
        run: |
          sed -i "s|newTag:.*|newTag: \"${{ inputs.image_tag }}\"|g" infra/k8s/overlays/prod/kustomization.yaml

          echo "üìù Updated production kustomization:"
          cat infra/k8s/overlays/prod/kustomization.yaml

      - name: Commit and push branch
        run: |
          git add infra/k8s/overlays/prod/kustomization.yaml
          git commit -m "üöÄ Deploy to production: ${{ inputs.image_tag }}"
          git push origin ${{ env.BRANCH_NAME }}

      - name: Create Pull Request
        id: create-pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_URL=$(gh pr create \
            --title "üöÄ Production Deploy: ${{ inputs.image_tag }}" \
            --body "## Production Deployment

          ### üì¶ Image Tag
          \`${{ inputs.image_tag }}\`

          ### üéØ Deployment Strategy
          Blue-Green (Argo Rollouts)

          ### ‚ö° What happens next?
          1. Status checks run (GitOps validation)
          2. PR auto-merges after checks pass
          3. Preview deployment starts
          4. Smoke tests run on preview URL
          5. Manual approval required for promotion
          6. Traffic switches to new version

          ---
          *ü§ñ Triggered by: @${{ github.actor }}*" \
            --base main \
            --head ${{ env.BRANCH_NAME }})

          PR_NUMBER=$(gh pr list --head ${{ env.BRANCH_NAME }} --json number --jq '.[0].number')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Created PR #$PR_NUMBER: $PR_URL"

      - name: Wait for checks
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚úÖ PR created: #${{ steps.create-pr.outputs.pr_number }}"
          echo "‚è∏Ô∏è  Waiting for status checks to complete..."

          # Wait for checks to complete (GitOps validation)
          echo "‚è≥ Waiting 60 seconds for CI checks and ArgoCD validation..."
          sleep 60

          # Check if PR is already merged (manual merge)
          PR_STATE=$(gh pr view ${{ steps.create-pr.outputs.pr_number }} --json state --jq '.state')

          if [ "$PR_STATE" = "MERGED" ]; then
            echo "‚úÖ PR already merged manually - skipping auto-merge"
            exit 0
          fi

          # Merge the PR if not already merged
          echo "üîÄ Merging PR..."
          gh pr merge ${{ steps.create-pr.outputs.pr_number }} --squash --auto --delete-branch || {
            echo "‚ö†Ô∏è Auto-merge may have already been enabled or PR is merging"
          }
          echo "‚úÖ PR merge initiated"

      - name: Wait for PR to merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚è≥ Waiting for PR to merge..."

          for i in {1..30}; do
            # Check PR state
            PR_STATE=$(gh pr view ${{ steps.create-pr.outputs.pr_number }} --json state --jq '.state')
            
            if [ "$PR_STATE" = "MERGED" ]; then
              echo "‚úÖ PR #${{ steps.create-pr.outputs.pr_number }} merged successfully!"
              
              # Ensure branch is deleted using GitHub API
              sleep 3
              BRANCH="${{ env.BRANCH_NAME }}"
              gh api -X DELETE "repos/${{ github.repository }}/git/refs/heads/$BRANCH" 2>&1 || echo "Branch already deleted"
              
              exit 0
            elif [ "$PR_STATE" = "CLOSED" ]; then
              echo "‚ùå PR was closed without merging"
              exit 1
            fi
            
            echo "Attempt $i/30 - State: $PR_STATE"
            sleep 5
          done

          echo "‚ö†Ô∏è Timeout waiting for merge. Proceeding anyway..."

  # ============================================
  # JOB 3: Deploy Preview (Blue-Green)
  # ============================================
  deploy-preview:
    name: Deploy Preview (Green)
    runs-on: ubuntu-latest
    needs: [validate, update-manifests]
    environment:
      name: production-preview
      url: ${{ env.PREVIEW_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Save kubeconfig
        run: doctl kubernetes cluster kubeconfig save ai-incident-assistant

      - name: Install Argo Rollouts CLI
        run: |
          curl -LO https://github.com/argoproj/argo-rollouts/releases/download/v1.6.4/kubectl-argo-rollouts-linux-amd64
          chmod +x kubectl-argo-rollouts-linux-amd64
          sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts

      - name: Sync ArgoCD
        run: |
          echo "üîÑ Triggering ArgoCD sync for production..."
          kubectl patch application ai-incident-prod -n argocd \
            --type merge \
            -p '{"operation": {"initiatedBy": {"username": "github-actions"}, "sync": {"revision": "HEAD"}}}' \
            || echo "‚ö†Ô∏è Manual sync may be required"

      - name: Wait for ArgoCD to create rollouts
        run: |
          echo "‚è≥ Waiting for ArgoCD to create rollout resources..."

          # Wait up to 3 minutes for rollouts to be created
          for i in {1..36}; do
            BACKEND_EXISTS=$(kubectl get rollout backend -n ${{ env.PROD_NAMESPACE }} 2>/dev/null && echo "true" || echo "false")
            FRONTEND_EXISTS=$(kubectl get rollout frontend -n ${{ env.PROD_NAMESPACE }} 2>/dev/null && echo "true" || echo "false")
            
            if [ "$BACKEND_EXISTS" = "true" ] && [ "$FRONTEND_EXISTS" = "true" ]; then
              echo "‚úÖ Rollouts created successfully!"
              break
            fi
            
            echo "Waiting for rollouts to be created... ($i/36)"
            sleep 5
          done

      - name: Wait for preview deployment
        run: |
          echo "‚è≥ Waiting for preview (green) deployment..."

          # Check if rollouts exist before checking status
          if ! kubectl get rollout backend -n ${{ env.PROD_NAMESPACE }} > /dev/null 2>&1; then
            echo "‚ùå Backend rollout not found - ArgoCD may not have synced yet"
            exit 1
          fi

          if ! kubectl get rollout frontend -n ${{ env.PROD_NAMESPACE }} > /dev/null 2>&1; then
            echo "‚ùå Frontend rollout not found - ArgoCD may not have synced yet"
            exit 1
          fi

          # Wait for rollout to complete
          kubectl-argo-rollouts status backend -n ${{ env.PROD_NAMESPACE }} --timeout 5m || true
          kubectl-argo-rollouts status frontend -n ${{ env.PROD_NAMESPACE }} --timeout 5m || true

      - name: Get rollout status
        run: |
          echo "üìã Backend Rollout Status:"
          kubectl-argo-rollouts get rollout backend -n ${{ env.PROD_NAMESPACE }} || echo "‚ö†Ô∏è Backend rollout not found"

          echo ""
          echo "üìã Frontend Rollout Status:"
          kubectl-argo-rollouts get rollout frontend -n ${{ env.PROD_NAMESPACE }} || echo "‚ö†Ô∏è Frontend rollout not found"

      - name: Display preview URL
        run: |
          echo ""
          echo "üîó Preview URL: ${{ env.PREVIEW_URL }}"
          echo ""
          echo "The new version is now available at the preview URL."
          echo "Production traffic still goes to the old version."

  # ============================================
  # JOB 4: Smoke Tests on Preview
  # ============================================
  smoke-tests:
    name: Smoke Tests (Preview)
    runs-on: ubuntu-latest
    needs: [deploy-preview]
    if: ${{ inputs.skip_smoke_test != true }}

    steps:
      - name: Wait for preview to be accessible
        run: |
          echo "‚è≥ Waiting for preview to be accessible..."
          for i in {1..30}; do
            if curl -sf "${{ env.PREVIEW_URL }}" > /dev/null; then
              echo "‚úÖ Preview is accessible!"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 10
          done

      - name: Run smoke tests
        run: |
          echo "üî• Running enhanced smoke tests on preview..."
          FAILED=0

          # Test 1: Frontend loads
          echo "1Ô∏è‚É£ Testing frontend loads..."
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PREVIEW_URL }}")
          if [ "$FRONTEND_STATUS" = "200" ]; then
            echo "   ‚úÖ Frontend: OK ($FRONTEND_STATUS)"
          else
            echo "   ‚ùå Frontend: FAILED ($FRONTEND_STATUS)"
            FAILED=1
          fi

          # Test 2: Backend health endpoint
          echo "2Ô∏è‚É£ Testing backend health..."
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PREVIEW_URL }}/api/health")
          if [ "$API_STATUS" = "200" ]; then
            echo "   ‚úÖ Backend Health: OK ($API_STATUS)"
          else
            echo "   ‚ùå Backend Health: FAILED ($API_STATUS)"
            FAILED=1
          fi

          # Test 3: Backend returns valid JSON
          echo "3Ô∏è‚É£ Testing API response format..."
          API_RESPONSE=$(curl -s "${{ env.PREVIEW_URL }}/api/health")
          if echo "$API_RESPONSE" | jq . > /dev/null 2>&1; then
            echo "   ‚úÖ API Response: Valid JSON"
            echo "   Response: $API_RESPONSE"
          else
            echo "   ‚ùå API Response: Invalid JSON"
            echo "   Response: $API_RESPONSE"
            FAILED=1
          fi

          # Test 4: Database connectivity (via incidents endpoint)
          echo "4Ô∏è‚É£ Testing database connectivity..."
          DB_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PREVIEW_URL }}/api/incidents")
          if [ "$DB_STATUS" = "200" ] || [ "$DB_STATUS" = "401" ]; then
            echo "   ‚úÖ Database: Connected (status $DB_STATUS)"
          else
            echo "   ‚ùå Database: Connection failed ($DB_STATUS)"
            FAILED=1
          fi

          # Test 5: Response time check
          echo "5Ô∏è‚É£ Testing response time..."
          RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "${{ env.PREVIEW_URL }}/api/health")
          if (( $(echo "$RESPONSE_TIME < 2.0" | bc -l) )); then
            echo "   ‚úÖ Response Time: ${RESPONSE_TIME}s (< 2s)"
          else
            echo "   ‚ö†Ô∏è Response Time: ${RESPONSE_TIME}s (slow but acceptable)"
          fi

          if [ $FAILED -eq 1 ]; then
            echo ""
            echo "‚ùå Smoke tests FAILED!"
            exit 1
          fi

          echo ""
          echo "‚úÖ All smoke tests passed!"

      - name: Test critical endpoints
        run: |
          echo "üß™ Testing critical endpoints..."

          # Test incidents endpoint
          curl -sf "${{ env.PREVIEW_URL }}/api/incidents" > /dev/null && echo "‚úÖ /api/incidents" || echo "‚ö†Ô∏è /api/incidents (may need auth)"

          # Test dashboard endpoint
          curl -sf "${{ env.PREVIEW_URL }}/api/dashboard" > /dev/null && echo "‚úÖ /api/dashboard" || echo "‚ö†Ô∏è /api/dashboard (may need auth)"

          echo ""
          echo "‚úÖ Critical endpoint tests completed!"

  # ============================================
  # JOB 5: Promote to Production
  # ============================================
  promote:
    name: Promote to Production
    runs-on: ubuntu-latest
    needs: [validate, smoke-tests]
    if: ${{ always() && (needs.smoke-tests.result == 'success' || inputs.skip_smoke_test == true) }}
    environment:
      name: production
      url: ${{ env.PROD_URL }}

    steps:
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Save kubeconfig
        run: doctl kubernetes cluster kubeconfig save ai-incident-assistant

      - name: Install Argo Rollouts CLI
        run: |
          curl -LO https://github.com/argoproj/argo-rollouts/releases/download/v1.6.4/kubectl-argo-rollouts-linux-amd64
          chmod +x kubectl-argo-rollouts-linux-amd64
          sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts

      - name: Check if auto-promote
        id: check-promote
        run: |
          if [ "${{ inputs.auto_promote }}" = "true" ]; then
            echo "should_promote=true" >> $GITHUB_OUTPUT
            echo "üöÄ Auto-promote enabled, promoting immediately..."
          else
            echo "should_promote=true" >> $GITHUB_OUTPUT
            echo "‚è≥ Manual promotion through GitHub environment approval..."
          fi

      - name: Promote backend rollout
        if: steps.check-promote.outputs.should_promote == 'true'
        run: |
          echo "üöÄ Promoting backend to production..."
          kubectl-argo-rollouts promote backend -n ${{ env.PROD_NAMESPACE }}

          echo "‚è≥ Waiting for backend promotion..."
          kubectl-argo-rollouts status backend -n ${{ env.PROD_NAMESPACE }} --timeout 5m

      - name: Promote frontend rollout
        if: steps.check-promote.outputs.should_promote == 'true'
        run: |
          echo "üöÄ Promoting frontend to production..."
          kubectl-argo-rollouts promote frontend -n ${{ env.PROD_NAMESPACE }}

          echo "‚è≥ Waiting for frontend promotion..."
          kubectl-argo-rollouts status frontend -n ${{ env.PROD_NAMESPACE }} --timeout 5m

      - name: Verify production deployment
        run: |
          echo "üîç Verifying production deployment..."

          # Check rollout status
          echo "üìã Backend Status:"
          kubectl-argo-rollouts get rollout backend -n ${{ env.PROD_NAMESPACE }}

          echo ""
          echo "üìã Frontend Status:"
          kubectl-argo-rollouts get rollout frontend -n ${{ env.PROD_NAMESPACE }}

          # Verify production is accessible
          echo ""
          echo "üåê Testing production URL..."
          PROD_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PROD_URL }}")
          if [ "$PROD_STATUS" = "200" ]; then
            echo "‚úÖ Production is live: ${{ env.PROD_URL }}"
          else
            echo "‚ö†Ô∏è Production returned: $PROD_STATUS"
          fi

      - name: Monitor production health (5 minutes)
        run: |
          echo "üìä Monitoring production health for 5 minutes..."
          echo "   This ensures the deployment is stable before completing."
          echo ""

          echo "‚è≥ Waiting 60 seconds for application warmup..."
          sleep 60
          echo "‚úÖ Warmup complete, starting health checks..."
          echo ""

          FAILURES=0
          MAX_FAILURES=3

          for i in {1..10}; do
            echo "Check $i/10 ($(date '+%H:%M:%S'))"
            
            # Check frontend
            FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PROD_URL }}" 2>/dev/null || echo "000")
            
            # Check backend API
            API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PROD_URL }}/api/health" 2>/dev/null || echo "000")
            
            # Check response time
            RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "${{ env.PROD_URL }}/api/health" 2>/dev/null || echo "999")
            
            if [ "$FRONTEND_STATUS" = "200" ] && [ "$API_STATUS" = "200" ]; then
              echo "   ‚úÖ Frontend: $FRONTEND_STATUS | API: $API_STATUS | Response: ${RESPONSE_TIME}s"
              FAILURES=0
            else
              echo "   ‚ùå Frontend: $FRONTEND_STATUS | API: $API_STATUS"
              FAILURES=$((FAILURES + 1))
              
              if [ $FAILURES -ge $MAX_FAILURES ]; then
                echo ""
                echo "‚ùå Production health check FAILED!"
                echo "   $MAX_FAILURES consecutive failures detected."
                echo "   üîô Consider rolling back!"
                exit 1
              fi
            fi
            
            # Wait 30 seconds between checks (10 checks = 5 minutes)
            if [ $i -lt 10 ]; then
              sleep 30
            fi
          done

          echo ""
          echo "‚úÖ Production health monitoring complete - all checks passed!"
          echo "   Deployment is stable and serving traffic successfully."

  # ============================================
  # JOB 6: Notify
  # ============================================
  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: [validate, promote]
    if: ${{ needs.promote.result == 'success' }}

    steps:
      - name: Send Slack - Production Success
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "üöÄ Production deployment successful!",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "üöÄ Production Deployment Complete"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Image Tag:*\n`${{ inputs.image_tag }}`"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Deployed by:*\n${{ github.actor }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Strategy:*\nBlue-Green ‚úÖ"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Smoke Tests:*\n${{ inputs.skip_smoke_test && '‚è≠Ô∏è Skipped' || '‚úÖ Passed' }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üåê <${{ env.PROD_URL }}|View Production>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

  notify-failure:
    name: Notify Failure
    runs-on: ubuntu-latest
    needs: [validate, deploy-preview, smoke-tests, promote]
    if: ${{ always() && (needs.validate.result == 'failure' || needs.deploy-preview.result == 'failure' || needs.smoke-tests.result == 'failure' || needs.promote.result == 'failure') }}

    steps:
      - name: Send Slack - Failure
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "‚ùå Production deployment failed!",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "‚ùå Production Deployment Failed"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Image Tag:*\n`${{ inputs.image_tag }}`"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Triggered by:*\n${{ github.actor }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "‚ö†Ô∏è The preview deployment may still be active. Check Argo Rollouts dashboard to abort if needed.\n\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|üîó View Failed Run>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

  # ============================================
  # JOB 7: Automated Rollback (if health fails)
  # ============================================
  rollback:
    name: Automated Rollback
    runs-on: ubuntu-latest
    needs: [promote]
    if: ${{ always() && needs.promote.result == 'failure' }}

    steps:
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Save kubeconfig
        run: doctl kubernetes cluster kubeconfig save ai-incident-assistant

      - name: Install Argo Rollouts CLI
        run: |
          curl -LO https://github.com/argoproj/argo-rollouts/releases/download/v1.6.4/kubectl-argo-rollouts-linux-amd64
          chmod +x kubectl-argo-rollouts-linux-amd64
          sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts

      - name: Check rollout status
        id: check-status
        run: |
          echo "üîç Checking rollout status before abort..."

          # Check if rollouts are in progress or degraded
          BACKEND_STATUS=$(kubectl-argo-rollouts status backend -n ${{ env.PROD_NAMESPACE }} --timeout 5s 2>&1 || echo "ERROR")
          FRONTEND_STATUS=$(kubectl-argo-rollouts status frontend -n ${{ env.PROD_NAMESPACE }} --timeout 5s 2>&1 || echo "ERROR")

          echo "Backend: $BACKEND_STATUS"
          echo "Frontend: $FRONTEND_STATUS"

          # Determine if rollback is needed
          if [[ "$BACKEND_STATUS" == *"ERROR"* ]] || [[ "$FRONTEND_STATUS" == *"ERROR"* ]]; then
            echo "needs_rollback=true" >> $GITHUB_OUTPUT
          else
            echo "needs_rollback=false" >> $GITHUB_OUTPUT
          fi

      - name: Abort and rollback
        if: steps.check-status.outputs.needs_rollback == 'true'
        run: |
          echo "üîô AUTOMATED ROLLBACK INITIATED"
          echo "================================"
          echo "Reason: Health monitoring detected failures"
          echo "Action: Aborting rollout and reverting to stable version"
          echo ""

          # Abort backend rollout
          echo "‚èπÔ∏è Aborting backend rollout..."
          kubectl-argo-rollouts abort backend -n ${{ env.PROD_NAMESPACE }} || echo "Backend already aborted or not in progress"

          # Abort frontend rollout
          echo "‚èπÔ∏è Aborting frontend rollout..."
          kubectl-argo-rollouts abort frontend -n ${{ env.PROD_NAMESPACE }} || echo "Frontend already aborted or not in progress"

          # Verify stable revision is active
          echo ""
          echo "üîç Verifying stable version is active..."

          sleep 10

          BACKEND_STABLE=$(kubectl-argo-rollouts get rollout backend -n ${{ env.PROD_NAMESPACE }} | grep -c "‚úî Healthy" || echo "0")
          FRONTEND_STABLE=$(kubectl-argo-rollouts get rollout frontend -n ${{ env.PROD_NAMESPACE }} | grep -c "‚úî Healthy" || echo "0")

          echo "Backend stable instances: $BACKEND_STABLE"
          echo "Frontend stable instances: $FRONTEND_STABLE"

          echo ""
          echo "‚úÖ Rollback complete. Previous stable version is active."
          echo "   Production traffic is now serving the previous version."

      - name: Post rollback verification
        if: steps.check-status.outputs.needs_rollback == 'true'
        run: |
          echo "üîç Post-rollback verification..."

          # Wait a bit for DNS/load balancer to update
          sleep 15

          # Test production URL
          PROD_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PROD_URL }}" 2>/dev/null || echo "000")
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PROD_URL }}/api/health" 2>/dev/null || echo "000")

          echo "Production URL: $PROD_STATUS"
          echo "API Health: $API_STATUS"

          if [ "$PROD_STATUS" = "200" ] && [ "$API_STATUS" = "200" ]; then
            echo "‚úÖ Production is healthy after rollback"
          else
            echo "‚ö†Ô∏è Production may still be recovering. Manual intervention may be needed."
          fi

      - name: Send rollback notification
        if: steps.check-status.outputs.needs_rollback == 'true'
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "üîô AUTOMATED ROLLBACK EXECUTED",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "üîô Production Rollback Executed"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Failed Image:*\n`${{ inputs.image_tag }}`"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Triggered by:*\n${{ github.actor }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Reason:*\nHealth monitoring failure"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Status:*\nReverted to stable version"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "‚ö†Ô∏è *Action Required:*\n‚Ä¢ Investigate failure logs\n‚Ä¢ Fix issues before redeploying\n‚Ä¢ Previous stable version is now active\n\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|üîó View Rollback Details>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      - name: Cleanup deployment branch
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="${{ needs.update-manifests.outputs.branch_name }}"

          if [ -z "$BRANCH" ]; then
            echo "No branch to cleanup"
            exit 0
          fi

          echo "üßπ Deleting deployment branch: $BRANCH..."
          gh api -X DELETE "repos/${{ github.repository }}/git/refs/heads/$BRANCH" 2>&1 || echo "Branch already deleted"
          echo "‚úÖ Branch cleanup complete"
