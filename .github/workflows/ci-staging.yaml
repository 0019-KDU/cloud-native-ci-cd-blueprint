name: CI/CD - Staging Environment

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (leave empty for latest from dev)"
        required: false
        type: string
      skip_tests:
        description: "Skip all tests (emergency deploys only)"
        required: false
        type: boolean
        default: false
      run_load_test:
        description: "Run load tests"
        required: false
        type: boolean
        default: true
      run_e2e_test:
        description: "Run E2E tests"
        required: false
        type: boolean
        default: true

concurrency:
  group: staging-deployment
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  actions: write

env:
  # ===== Repo (IMPORTANT for ArgoCD) =====
  # Must be a real git URL that ArgoCD can clone (and ArgoCD must have repo credentials configured)
  REPO_URL: https://github.com/0019-KDU/cloud-native-ci-cd-blueprint.git

  # ===== Infrastructure =====
  REGISTRY: registry.digitalocean.com
  IMAGE_NAME: ai-incident-assistant
  CLUSTER_NAME: ai-incident-assistant

  # ===== Main staging (ArgoCD app that tracks main) =====
  STAGING_NAMESPACE: staging
  STAGING_URL: https://staging.example.com
  ARGOCD_APP_NAME: ai-incident-staging

  # ===== Timeouts =====
  DEPLOYMENT_TIMEOUT: 5m

  # ===== Load Test Config =====
  LOAD_TEST_DURATION: 5m
  LOAD_TEST_USERS: "50"

jobs:
  # ============================================
  # JOB 1: Validate & Prepare
  # ============================================
  prepare:
    name: Validate & Prepare
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      image_tag: ${{ steps.resolve-tag.outputs.image_tag }}
      short_sha: ${{ steps.resolve-tag.outputs.short_sha }}
      needs_deployment: ${{ steps.check-state.outputs.needs_deployment }}
      current_staging_tag: ${{ steps.check-state.outputs.current_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install yq
        run: |
          sudo snap install yq

      - name: Resolve image tag
        id: resolve-tag
        shell: bash
        run: |
          if [[ -n "${{ inputs.image_tag }}" ]]; then
            IMAGE_TAG="${{ inputs.image_tag }}"
            echo "ðŸ“¦ Using provided image tag: $IMAGE_TAG"
          else
            IMAGE_TAG="$(yq '.images[0].newTag' infra/k8s/overlays/dev/kustomization.yaml | tr -d '"')"
            echo "ðŸ“¦ Using dev image tag: $IMAGE_TAG"
          fi

          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "short_sha=${IMAGE_TAG:0:7}" >> "$GITHUB_OUTPUT"

      - name: Check current staging state (from repo manifest)
        id: check-state
        shell: bash
        run: |
          CURRENT_TAG="$(yq '.images[0].newTag' infra/k8s/overlays/staging/kustomization.yaml | tr -d '"')"
          TARGET_TAG="${{ steps.resolve-tag.outputs.image_tag }}"

          echo "current_tag=$CURRENT_TAG" >> "$GITHUB_OUTPUT"

          if [[ "$CURRENT_TAG" == "$TARGET_TAG" ]]; then
            echo "needs_deployment=false" >> "$GITHUB_OUTPUT"
            echo "âœ… Staging already at $TARGET_TAG - tests only"
          else
            echo "needs_deployment=true" >> "$GITHUB_OUTPUT"
            echo "ðŸ”„ Staging update: $CURRENT_TAG â†’ $TARGET_TAG"
          fi

  # ============================================
  # JOB 2: Create Deployment PR (complies with repo rules)
  # ============================================
  create-pr:
    name: Create Deployment PR
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [prepare]
    if: needs.prepare.outputs.needs_deployment == 'true'
    outputs:
      pr_number: ${{ steps.create-pr.outputs.pr_number }}
      pr_url: ${{ steps.create-pr.outputs.pr_url }}
      branch_name: ${{ steps.branch.outputs.name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Install tools (yq + kubectl)
        run: |
          sudo snap install yq --classic
          sudo snap install kubectl --classic

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create feature branch
        id: branch
        shell: bash
        run: |
          BRANCH="deploy/staging-${{ needs.prepare.outputs.image_tag }}-$(date +%s)"
          git checkout -b "$BRANCH"
          echo "name=$BRANCH" >> "$GITHUB_OUTPUT"

      - name: Update staging manifests (PR change)
        shell: bash
        run: |
          yq -i '.images[0].newTag = "${{ needs.prepare.outputs.image_tag }}"' infra/k8s/overlays/staging/kustomization.yaml
          echo "ðŸ“ Updated staging manifests:"
          yq '.images' infra/k8s/overlays/staging/kustomization.yaml

      - name: Validate manifests
        shell: bash
        run: |
          kubectl kustomize infra/k8s/overlays/staging > /dev/null
          echo "âœ… Manifests are valid"

      - name: Commit and push branch
        shell: bash
        run: |
          git add infra/k8s/overlays/staging/kustomization.yaml
          git commit -m "chore(staging): deploy ${{ needs.prepare.outputs.image_tag }}"
          git push origin "${{ steps.branch.outputs.name }}"

      - name: Create Pull Request
        id: create-pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          PR_URL="$(gh pr create \
            --title "chore(staging): deploy ${{ needs.prepare.outputs.short_sha }}" \
            --body "Automated staging deploy PR - Image: ${{ needs.prepare.outputs.image_tag }} - Previous: ${{ needs.prepare.outputs.current_staging_tag }} - By: ${{ github.actor }} - Do not merge manually, workflow will merge after approval." \
            --base main \
            --head "${{ steps.branch.outputs.name }}")"

          PR_NUMBER="$(gh pr view --json number -q '.number')"

          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
          echo "âœ… Created PR #$PR_NUMBER: $PR_URL"

  # ============================================
  # JOB 3: Deploy Preview via ArgoCD (isolated namespace so it won't fight main)
  # ============================================
  deploy-preview:
    name: Deploy Preview Environment (ArgoCD)
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [prepare, create-pr]
    if: needs.create-pr.result == 'success'
    outputs:
      preview_url: ${{ steps.deploy.outputs.preview_url }}
      app_name: ${{ steps.deploy.outputs.app_name }}
      preview_ns: ${{ steps.deploy.outputs.preview_ns }}

    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create-pr.outputs.branch_name }}

      - name: Install doctl
        run: |
          sudo snap install doctl
          sudo snap connect doctl:kube-config

      - name: Setup Kubernetes
        run: |
          mkdir -p $HOME/.kube
          doctl auth init --access-token ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          doctl kubernetes cluster kubeconfig save ${{ env.CLUSTER_NAME }}
          echo "âœ… Kubernetes configured"

      - name: Deploy ArgoCD Preview Application
        id: deploy
        shell: bash
        run: |
          SHORT="${{ needs.prepare.outputs.short_sha }}"
          PREVIEW_APP="staging-preview-$SHORT"
          PREVIEW_NS="staging-preview-$SHORT"

          # IMPORTANT:
          # - repoURL MUST be a cloneable git URL (env.REPO_URL)
          # - targetRevision uses the PR branch name
          # - destination namespace is UNIQUE per preview (so it doesn't fight the main staging app)
          cat <<EOF | kubectl apply -f -
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: $PREVIEW_APP
            namespace: argocd
            labels:
              preview: "true"
            finalizers:
              - resources-finalizer.argocd.argoproj.io
          spec:
            project: default
            source:
              repoURL: ${{ env.REPO_URL }}
              targetRevision: ${{ needs.create-pr.outputs.branch_name }}
              path: infra/k8s/overlays/staging
            destination:
              server: https://kubernetes.default.svc
              namespace: $PREVIEW_NS
            syncPolicy:
              automated:
                prune: true
                selfHeal: true
              syncOptions:
                - CreateNamespace=true
                - PruneLast=true
          EOF

          echo "app_name=$PREVIEW_APP" >> "$GITHUB_OUTPUT"
          echo "preview_ns=$PREVIEW_NS" >> "$GITHUB_OUTPUT"

          # Your routing MUST point to this preview namespace.
          # If you don't have per-namespace routing, set this to whatever URL hits the preview.
          echo "preview_url=${{ env.STAGING_URL }}" >> "$GITHUB_OUTPUT"

      - name: Wait for ArgoCD sync + health (poll)
        shell: bash
        run: |
          APP="${{ steps.deploy.outputs.app_name }}"

          echo "â³ Waiting for sync/health on $APP..."
          for i in {1..60}; do
            SYNC="$(kubectl get app "$APP" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || true)"
            HEALTH="$(kubectl get app "$APP" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || true)"
            echo "[$i/60] Sync=$SYNC Health=$HEALTH"
            if [[ "$SYNC" == "Synced" && "$HEALTH" == "Healthy" ]]; then
              echo "âœ… Preview deployment healthy!"
              exit 0
            fi
            sleep 5
          done

          echo "âŒ Preview app did not become healthy in time"
          kubectl get app "$APP" -n argocd -o yaml || true
          exit 1

      - name: Verify rollouts in preview namespace
        shell: bash
        run: |
          NS="${{ steps.deploy.outputs.preview_ns }}"
          kubectl rollout status deployment/backend -n "$NS" --timeout=${{ env.DEPLOYMENT_TIMEOUT }}
          kubectl rollout status deployment/frontend -n "$NS" --timeout=${{ env.DEPLOYMENT_TIMEOUT }}

      - name: Update PR with preview status
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          gh pr comment "${{ needs.create-pr.outputs.pr_number }}" --body "Preview Deployed - App: ${{ steps.deploy.outputs.app_name }} - Namespace: ${{ steps.deploy.outputs.preview_ns }} - URL: ${{ steps.deploy.outputs.preview_url }} - Running tests..."

  # ============================================
  # JOB 4: E2E Tests (target preview)
  # ============================================
  e2e-tests:
    name: E2E Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [prepare, create-pr, deploy-preview]
    if: inputs.skip_tests != true && inputs.run_e2e_test != false && needs.deploy-preview.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install doctl
        run: |
          sudo snap install doctl
          sudo snap connect doctl:kube-config

      - name: Setup Kubernetes
        run: |
          mkdir -p $HOME/.kube
          doctl auth init --access-token ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          doctl kubernetes cluster kubeconfig save ${{ env.CLUSTER_NAME }}
          echo "âœ… Kubernetes configured"

      - name: Install Argo CLI
        run: |
          echo "ðŸ“¦ Installing Argo CLI v3.5.4..."
          curl -sLO "https://github.com/argoproj/argo-workflows/releases/download/v3.5.4/argo-linux-amd64.gz"
          gunzip argo-linux-amd64.gz
          chmod +x argo-linux-amd64
          sudo mv argo-linux-amd64 /usr/local/bin/argo
          argo version
          echo "âœ… Argo CLI ready"

      - name: Run E2E workflow (Argo Workflows)
        id: e2e
        shell: bash
        run: |
          WORKFLOW_NAME="$(argo submit infra/argo-workflows/e2e-tests.yaml \
            -n argo \
            --parameter image_tag=${{ needs.prepare.outputs.image_tag }} \
            --parameter target_url=${{ needs.deploy-preview.outputs.preview_url }} \
            --parameter namespace=${{ needs.deploy-preview.outputs.preview_ns }} \
            --wait \
            --log \
            -o name)"

          echo "workflow_name=$WORKFLOW_NAME" >> "$GITHUB_OUTPUT"

      - name: Check E2E result
        if: always()
        shell: bash
        run: |
          STATUS="$(argo get "${{ steps.e2e.outputs.workflow_name }}" -n argo -o json | jq -r '.status.phase')"
          if [[ "$STATUS" != "Succeeded" ]]; then
            echo "âŒ E2E failed"
            exit 1
          fi
          echo "âœ… E2E passed"

  # ============================================
  # JOB 5: Load Tests (target preview)
  # ============================================
  load-tests:
    name: Load Tests
    runs-on: ubuntu-latest
    timeout-minutes: 40
    needs: [prepare, create-pr, deploy-preview, e2e-tests]
    if: |
      inputs.skip_tests != true &&
      inputs.run_load_test != false &&
      needs.deploy-preview.result == 'success' &&
      (needs.e2e-tests.result == 'success' || needs.e2e-tests.result == 'skipped')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install doctl
        run: |
          sudo snap install doctl
          sudo snap connect doctl:kube-config

      - name: Setup Kubernetes
        run: |
          mkdir -p $HOME/.kube
          doctl auth init --access-token ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          doctl kubernetes cluster kubeconfig save ${{ env.CLUSTER_NAME }}
          echo "âœ… Kubernetes configured"

      - name: Install Argo CLI
        run: |
          echo "ðŸ“¦ Installing Argo CLI v3.5.4..."
          curl -sLO "https://github.com/argoproj/argo-workflows/releases/download/v3.5.4/argo-linux-amd64.gz"
          gunzip argo-linux-amd64.gz
          chmod +x argo-linux-amd64
          sudo mv argo-linux-amd64 /usr/local/bin/argo
          argo version
          echo "âœ… Argo CLI ready"

      - name: Run Load workflow (Argo Workflows)
        id: load
        shell: bash
        run: |
          WORKFLOW_NAME="$(argo submit infra/argo-workflows/load-tests.yaml \
            -n argo \
            --parameter image_tag=${{ needs.prepare.outputs.image_tag }} \
            --parameter target_url=${{ needs.deploy-preview.outputs.preview_url }} \
            --parameter namespace=${{ needs.deploy-preview.outputs.preview_ns }} \
            --parameter duration=${{ env.LOAD_TEST_DURATION }} \
            --parameter users=${{ env.LOAD_TEST_USERS }} \
            --wait \
            --log \
            -o name)"

          echo "workflow_name=$WORKFLOW_NAME" >> "$GITHUB_OUTPUT"

      - name: Check Load result
        if: always()
        shell: bash
        run: |
          STATUS="$(argo get "${{ steps.load.outputs.workflow_name }}" -n argo -o json | jq -r '.status.phase')"
          if [[ "$STATUS" != "Succeeded" ]]; then
            echo "âŒ Load tests failed"
            exit 1
          fi
          echo "âœ… Load tests passed"

  # ============================================
  # JOB 6: Approval Gate & Merge + Sync main staging app
  # ============================================
  approve-and-merge:
    name: Approve & Merge + Sync Main Staging
    runs-on: ubuntu-latest
    timeout-minutes: 90
    needs: [prepare, create-pr, deploy-preview, e2e-tests, load-tests]
    if: |
      needs.create-pr.result == 'success' &&
      (needs.e2e-tests.result == 'success' || needs.e2e-tests.result == 'skipped') &&
      (needs.load-tests.result == 'success' || needs.load-tests.result == 'skipped')
    environment:
      name: staging
      url: ${{ needs.deploy-preview.outputs.preview_url }}

    steps:
      - name: Install doctl
        run: |
          sudo snap install doctl
          sudo snap connect doctl:kube-config

      - name: Setup Kubernetes
        run: |
          mkdir -p $HOME/.kube
          doctl auth init --access-token ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          doctl kubernetes cluster kubeconfig save ${{ env.CLUSTER_NAME }}
          echo "âœ… Kubernetes configured"

      - name: Merge PR (after approval)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          PR="${{ needs.create-pr.outputs.pr_number }}"
          echo "âœ… Approved - merging PR #$PR"
          gh pr merge "$PR" --squash --delete-branch

      - name: Sync main staging ArgoCD app (tracking main)
        shell: bash
        run: |
          APP="${{ env.ARGOCD_APP_NAME }}"
          echo "ðŸ”„ Forcing refresh + waiting for main staging sync..."

          kubectl patch application "$APP" -n argocd --type merge \
            -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}' || true

          for i in {1..60}; do
            SYNC="$(kubectl get app "$APP" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || true)"
            HEALTH="$(kubectl get app "$APP" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || true)"
            echo "[$i/60] Sync=$SYNC Health=$HEALTH"
            if [[ "$SYNC" == "Synced" && "$HEALTH" == "Healthy" ]]; then
              echo "âœ… Main staging app synced & healthy"
              exit 0
            fi
            sleep 5
          done

          echo "âŒ Main staging app did not become healthy in time"
          kubectl get app "$APP" -n argocd -o yaml || true
          exit 1

      - name: Cleanup preview app + namespace
        if: always()
        shell: bash
        run: |
          PREVIEW_APP="${{ needs.deploy-preview.outputs.app_name }}"
          PREVIEW_NS="${{ needs.deploy-preview.outputs.preview_ns }}"

          kubectl delete application "$PREVIEW_APP" -n argocd --wait=false || true
          kubectl delete namespace "$PREVIEW_NS" --wait=false || true

  # ============================================
  # JOB 7: Notify
  # ============================================
  notify:
    name: Notify
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs:
      [
        prepare,
        create-pr,
        deploy-preview,
        e2e-tests,
        load-tests,
        approve-and-merge,
      ]
    if: always()

    steps:
      - name: Compose status
        id: s
        shell: bash
        run: |
          if [[ "${{ needs.approve-and-merge.result }}" == "success" ]]; then
            echo "emoji=âœ…" >> "$GITHUB_OUTPUT"
            echo "msg=Staging deployment merged & synced" >> "$GITHUB_OUTPUT"
          elif [[ "${{ needs.create-pr.result }}" == "skipped" ]]; then
            echo "emoji=â„¹ï¸" >> "$GITHUB_OUTPUT"
            echo "msg=No deployment needed (manifest already at target tag)" >> "$GITHUB_OUTPUT"
          else
            echo "emoji=âŒ" >> "$GITHUB_OUTPUT"
            echo "msg=Staging pipeline failed" >> "$GITHUB_OUTPUT"
          fi

      - name: Send Slack
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "${{ steps.s.outputs.emoji }} Staging: ${{ steps.s.outputs.msg }}",
              "blocks": [
                { "type": "header", "text": { "type": "plain_text", "text": "${{ steps.s.outputs.emoji }} Staging Pipeline" } },
                {
                  "type": "section",
                  "fields": [
                    { "type": "mrkdwn", "text": "*Message:*\n${{ steps.s.outputs.msg }}" },
                    { "type": "mrkdwn", "text": "*Image Tag:*\n`${{ needs.prepare.outputs.image_tag }}`" },
                    { "type": "mrkdwn", "text": "*PR:*\n${{ needs.create-pr.outputs.pr_url || 'N/A' }}" },
                    { "type": "mrkdwn", "text": "*Run:*\n${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" }
                  ]
                },
                {
                  "type": "context",
                  "elements": [
                    { "type": "mrkdwn", "text": "E2E: ${{ needs.e2e-tests.result }} | Load: ${{ needs.load-tests.result }} | Merge: ${{ needs.approve-and-merge.result }}" }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
