name: Production ArgoCD Sync

on:
    pull_request:
        types: [closed]
        branches:
            - main

jobs:
    sync-production:
        # Only run if PR was merged (not just closed) and branch starts with deploy/
        if: github.event.pull_request.merged == true && startsWith(github.event.pull_request.head.ref, 'deploy/')
        runs-on: ubuntu-latest
        steps:
            - name: Extract image tag from branch name
              id: extract-tag
              run: |
                  BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
                  IMAGE_TAG="${BRANCH_NAME#deploy/}"
                  echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
                  echo "Deploying image tag: $IMAGE_TAG"

            - name: Install doctl
              uses: digitalocean/action-doctl@v2
              with:
                  token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

            - name: Setup kubectl
              run: |
                  doctl kubernetes cluster kubeconfig save ${{ secrets.DIGITALOCEAN_CLUSTER_ID }}

            - name: Record deployment start metadata
              run: |
                  cat > deployment-metadata.json <<EOF
                  {
                    "deploymentId": "${{ github.run_id }}",
                    "imageTag": "${{ steps.extract-tag.outputs.image_tag }}",
                    "deployedAt": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                    "deployedBy": "${{ github.event.pull_request.merged_by.login }}",
                    "pullRequest": {
                      "number": ${{ github.event.pull_request.number }},
                      "title": "${{ github.event.pull_request.title }}",
                      "url": "${{ github.event.pull_request.html_url }}"
                    },
                    "environment": "production",
                    "status": "deploying"
                  }
                  EOF

                  echo "üìä Deployment metadata:"
                  cat deployment-metadata.json

            - name: Upload deployment metadata
              uses: actions/upload-artifact@v4
              with:
                  name: deployment-metadata-${{ github.run_id }}
                  path: deployment-metadata.json
                  retention-days: 365

            - name: Enable ArgoCD auto-rollback
              run: |
                  echo "üîÑ Configuring auto-rollback for production..."

                  # Enable auto-sync with automated rollback
                  kubectl patch application ai-incident-prod -n argocd \
                    --type merge \
                    -p '{
                      "spec": {
                        "syncPolicy": {
                          "automated": {
                            "prune": false,
                            "selfHeal": true,
                            "allowEmpty": false
                          },
                          "syncOptions": [
                            "CreateNamespace=false",
                            "PrunePropagationPolicy=foreground",
                            "PruneLast=true"
                          ],
                          "retry": {
                            "limit": 5,
                            "backoff": {
                              "duration": "5s",
                              "factor": 2,
                              "maxDuration": "3m"
                            }
                          }
                        }
                      }
                    }'

                  echo "‚úÖ Auto-rollback enabled"

            - name: Sync ArgoCD Application
              run: |
                  kubectl patch application ai-incident-prod -n argocd \
                    --type merge \
                    -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"revision":"HEAD"}}}'

                  echo "ArgoCD sync initiated for production environment"

            - name: Wait for sync to complete
              run: |
                  echo "Waiting for ArgoCD to sync production..."
                  for i in {1..30}; do
                    SYNC_STATUS=$(kubectl get application ai-incident-prod -n argocd -o jsonpath='{.status.sync.status}')
                    HEALTH_STATUS=$(kubectl get application ai-incident-prod -n argocd -o jsonpath='{.status.health.status}')
                    
                    echo "Attempt $i/30: Sync=$SYNC_STATUS, Health=$HEALTH_STATUS"
                    
                    if [ "$SYNC_STATUS" = "Synced" ] && [ "$HEALTH_STATUS" = "Healthy" ]; then
                      echo "‚úÖ Production deployment successful!"
                      exit 0
                    fi
                    
                    sleep 10
                  done

                  echo "‚ùå Timeout waiting for deployment to complete"
                  exit 1

            - name: Verify deployed images
              id: verify-images
              run: |
                  echo "Backend image:"
                  BACKEND_IMAGE=$(kubectl get deployment backend -n prod -o jsonpath='{.spec.template.spec.containers[0].image}')
                  echo "$BACKEND_IMAGE"
                  echo "backend_image=$BACKEND_IMAGE" >> $GITHUB_OUTPUT

                  echo ""
                  echo "Frontend image:"
                  FRONTEND_IMAGE=$(kubectl get deployment frontend -n prod -o jsonpath='{.spec.template.spec.containers[0].image}')
                  echo "$FRONTEND_IMAGE"
                  echo "frontend_image=$FRONTEND_IMAGE" >> $GITHUB_OUTPUT

            - name: Record deployment metadata
              if: always()
              run: |
                  STATUS="success"
                  if [ "${{ job.status }}" != "success" ]; then
                    STATUS="failed"
                  fi

                  mkdir -p artifacts
                  cat > artifacts/deployment-metadata.json <<EOF
                  {
                    "deploymentId": "${{ github.run_id }}",
                    "imageTag": "${{ steps.extract-tag.outputs.image_tag }}",
                    "deployedAt": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                    "deployedBy": "${{ github.event.pull_request.merged_by.login }}",
                    "pullRequest": {
                      "number": ${{ github.event.pull_request.number }},
                      "title": "${{ github.event.pull_request.title }}",
                      "url": "${{ github.event.pull_request.html_url }}"
                    },
                    "environment": "production",
                    "namespace": "prod",
                    "status": "$STATUS",
                    "deployedImages": {
                      "backend": "${{ steps.verify-images.outputs.backend_image }}",
                      "frontend": "${{ steps.verify-images.outputs.frontend_image }}"
                    },
                    "argocd": {
                      "application": "ai-incident-prod",
                      "syncStatus": "Synced",
                      "healthStatus": "Healthy",
                      "autoRollback": "enabled",
                      "server": "http://209.38.124.183"
                    },
                    "completedAt": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                  }
                  EOF

                  echo "üìä Deployment metadata:"
                  cat artifacts/deployment-metadata.json

            - name: Upload deployment metadata
              if: always()
              uses: actions/upload-artifact@v4
              with:
                  name: production-deployment-${{ github.run_id }}
                  path: artifacts/deployment-metadata.json
                  retention-days: 365

        outputs:
            image_tag: ${{ steps.extract-tag.outputs.image_tag }}
            backend_image: ${{ steps.verify-images.outputs.backend_image }}
            frontend_image: ${{ steps.verify-images.outputs.frontend_image }}

    post-deployment-smoke-test:
        needs: sync-production
        runs-on: ubuntu-latest
        steps:
            - name: Wait for services to stabilize
              run: sleep 30

            - name: Test production health endpoint
              run: |
                  response=$(curl -s -o /dev/null -w "%{http_code}" http://prod.174.138.120.13.nip.io/api)
                  if [ $response -eq 200 ]; then
                    echo "‚úÖ Health check passed (HTTP $response)"
                  else
                    echo "‚ùå Health check failed (HTTP $response)"
                    exit 1
                  fi

            - name: Test production frontend
              run: |
                  response=$(curl -s -o /dev/null -w "%{http_code}" http://prod.174.138.120.13.nip.io/)
                  if [ $response -eq 200 ]; then
                    echo "‚úÖ Frontend accessible (HTTP $response)"
                  else
                    echo "‚ùå Frontend check failed (HTTP $response)"
                    exit 1
                  fi

            - name: Test incidents API
              run: |
                  response=$(curl -s http://prod.174.138.120.13.nip.io/api/incidents)
                  if [ -n "$response" ]; then
                    echo "‚úÖ Incidents API responding"
                    echo "Response: $response"
                  else
                    echo "‚ùå Incidents API not responding"
                    exit 1
                  fi

            - name: Deployment summary
              if: always()
              run: |
                  echo "## üöÄ Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "**Image Tag:** ${{ needs.sync-production.outputs.image_tag || github.event.pull_request.head.ref }}" >> $GITHUB_STEP_SUMMARY
                  echo "**PR:** #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY
                  echo "**Deployed by:** @${{ github.event.pull_request.merged_by.login }}" >> $GITHUB_STEP_SUMMARY
                  echo "**Environment:** Production" >> $GITHUB_STEP_SUMMARY
                  echo "**URL:** http://prod.174.138.120.13.nip.io" >> $GITHUB_STEP_SUMMARY

            - name: Comment on PR
              if: always()
              uses: actions/github-script@v7
              with:
                  script: |
                      const status = '${{ job.status }}' === 'success' ? '‚úÖ Success' : '‚ùå Failed';
                      github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: ${{ github.event.pull_request.number }},
                        body: `## Production Deployment ${status}\n\n**Image:** \`${{ needs.sync-production.outputs.image_tag || github.event.pull_request.head.ref }}\`\n**Environment:** Production\n**URL:** http://prod.174.138.120.13.nip.io\n\nSmoke tests: ${status}`
                      });
